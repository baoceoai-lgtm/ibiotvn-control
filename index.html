#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <ArduinoJson.h>
#include <UniversalTelegramBot.h>

// ===================== WIFI =====================
const char* ssid = "TP-Link_F655";
const char* pass = "123654789";

// ===================== FIREBASE =====================
const char* FIREBASE_HOST = "xdkiot-default-rtdb.firebaseio.com";
String FIREBASE_AUTH = ""; // n·∫øu DB c√≥ auth token th√¨ ƒëi·ªÅn
String FIREBASE_PATH = "/led/state.json"; // node realtime: /led/state

// ===================== GPIO MAP (5 ch√¢n) =====================
const int PINtest = 2;   // GPIO2  -> idx 0
const int PIN1    = 16;  // GPIO16 -> idx 1
const int PIN2    = 17;  // GPIO17 -> idx 2
const int PIN3    = 18;  // GPIO18 -> idx 3
const int PIN4    = 19;  // GPIO19 -> idx 4

int gpioMap[5] = { PINtest, PIN1, PIN2, PIN3, PIN4 };
const char* keyMap[5] = { "PINtest", "PIN1", "PIN2", "PIN3", "PIN4" };

// ===================== TELEGRAM =====================
#define BOT_TOKEN "8572235039:AAH92Vix2eMLXdgEanuLB72-DxM9wjQalMY"

WiFiClientSecure tgClient;
UniversalTelegramBot bot(BOT_TOKEN, tgClient);

unsigned long lastTgPollMs = 0;
const unsigned long TG_POLL_MS = 800;

// ===================== TELEGRAM MENU (Reply Keyboard) =====================
String menuKeyboard =
  "[[\"Ki·ªÉm tra t√≠n hi·ªáu ON\",\"Ki·ªÉm tra t√≠n hi·ªáu OFF\"],"
   "[\"Thi·∫øt b·ªã 1 ON\",\"Thi·∫øt b·ªã 1 OFF\"],"
   "[\"Thi·∫øt b·ªã 2 ON\",\"Thi·∫øt b·ªã 2 OFF\"],"
   "[\"Thi·∫øt b·ªã 3 ON\",\"Thi·∫øt b·ªã 3 OFF\"],"
   "[\"Thi·∫øt b·ªã 4 ON\",\"Thi·∫øt b·ªã 4 OFF\"],"
   "[\"üìã MENU\"]]";

void showMenu(const String& chat_id) {
  bot.sendMessageWithReplyKeyboard(
    chat_id,
    "üéõ MENU ƒêI·ªÄU KHI·ªÇN ESP32",
    "",
    menuKeyboard,
    true, false, false
  );
}

// ===================== FIREBASE CLIENTS =====================
WiFiClientSecure sseClient;
WiFiClientSecure fbWriteClient;

String lineBuf = "";
String sseMsgData = "";
unsigned long lastStreamByteMs = 0;
unsigned long lastReconnectTryMs = 0;

// ===================== UTILS =====================
String buildFirebasePath(const String& basePath) {
  if (FIREBASE_AUTH.length() == 0) return basePath;
  if (basePath.indexOf('?') >= 0) return basePath + "&auth=" + FIREBASE_AUTH;
  return basePath + "?auth=" + FIREBASE_AUTH;
}

// ===================== GPIO APPLY =====================
void applyPinByIndex(int idx, int v) {
  if (idx < 0 || idx > 4) return;
  v = (v != 0) ? 1 : 0;
  digitalWrite(gpioMap[idx], v ? HIGH : LOW);
  Serial.printf("‚úÖ GPIO %s = %d\n", keyMap[idx], v);
}

void applyPinByName(const String& name, int v) {
  for (int i = 0; i < 5; i++) {
    if (name == keyMap[i]) {
      applyPinByIndex(i, v);
      return;
    }
  }
  Serial.println("‚ö†Ô∏è Unknown key: " + name);
}

// ===================== FIREBASE PATCH =====================
bool firebasePatchKey(const String& key, int v) {
  fbWriteClient.stop();
  fbWriteClient.setInsecure();

  String path = buildFirebasePath(FIREBASE_PATH);
  String payload = String("{\"") + key + "\":" + String((v != 0) ? 1 : 0) + "}";

  if (!fbWriteClient.connect(FIREBASE_HOST, 443)) {
    Serial.println("‚ùå PATCH connect failed");
    return false;
  }

  fbWriteClient.print(
    String("PATCH ") + path + " HTTP/1.1\r\n" +
    "Host: " + FIREBASE_HOST + "\r\n" +
    "Content-Type: application/json\r\n" +
    "Connection: close\r\n" +
    "Content-Length: " + String(payload.length()) + "\r\n\r\n" +
    payload
  );

  // ƒë·ªçc status line
  unsigned long start = millis();
  String status = "";
  while (millis() - start < 4000) {
    while (fbWriteClient.available()) {
      char c = (char)fbWriteClient.read();
      if (c == '\r') continue;
      if (c == '\n') goto PATCH_DONE;
      status += c;
    }
    delay(1);
  }
PATCH_DONE:
  fbWriteClient.stop();

  Serial.println("PATCH STATUS: " + status);
  int code = 0;
  int sp1 = status.indexOf(' ');
  if (sp1 > 0) code = status.substring(sp1 + 1).toInt();
  return (code >= 200 && code < 300);
}

// ===================== FIREBASE SSE (Realtime Listen) =====================
bool openSseStream() {
  sseClient.stop();
  sseClient.setInsecure();

  String path = buildFirebasePath(FIREBASE_PATH);

  if (!sseClient.connect(FIREBASE_HOST, 443)) {
    Serial.println("‚ùå SSE connect failed");
    return false;
  }

  sseClient.print(String("GET ") + path + " HTTP/1.1\r\n");
  sseClient.print(String("Host: ") + FIREBASE_HOST + "\r\n");
  sseClient.print("Accept: text/event-stream\r\n");
  sseClient.print("Connection: keep-alive\r\n\r\n");

  // ƒë·ªçc status line
  unsigned long start = millis();
  String status = "";
  while (millis() - start < 4000) {
    while (sseClient.available()) {
      char c = (char)sseClient.read();
      if (c == '\r') continue;
      if (c == '\n') goto SSE_STATUS_DONE;
      status += c;
    }
    delay(1);
  }
SSE_STATUS_DONE:
  Serial.println("SSE STATUS: " + status);

  int code = 0;
  int sp1 = status.indexOf(' ');
  if (sp1 > 0) code = status.substring(sp1 + 1).toInt();

  if (code != 200) {
    Serial.println("‚ùå SSE HTTP not 200");
    sseClient.stop();
    return false;
  }

  Serial.println("‚úÖ SSE stream opened!");
  lastStreamByteMs = millis();
  return true;
}

void handleFirebaseEvent(const String& jsonData) {
  StaticJsonDocument<1024> doc;
  DeserializationError err = deserializeJson(doc, jsonData);
  if (err) {
    Serial.println("‚ùå JSON parse error: " + String(err.c_str()));
    Serial.println("RAW: " + jsonData);
    return;
  }

  String path = doc["path"] | "";
  JsonVariant data = doc["data"];

  // Snapshot: {"path":"/","data":{...}}
  if (path == "/" && data.is<JsonObject>()) {
    for (JsonPair kv : data.as<JsonObject>()) {
      String key = kv.key().c_str();
      int v = 0;
      if (kv.value().is<int>()) v = kv.value().as<int>();
      else if (kv.value().is<bool>()) v = kv.value().as<bool>() ? 1 : 0;
      else if (kv.value().is<const char*>()) v = String(kv.value().as<const char*>()).toInt();
      applyPinByName(key, v);
    }
    return;
  }

  // Update: {"path":"/PIN1","data":1}
  if (path.startsWith("/")) {
    String key = path.substring(1);
    int v = 0;
    if (data.is<int>()) v = data.as<int>();
    else if (data.is<bool>()) v = data.as<bool>() ? 1 : 0;
    else if (data.is<const char*>()) v = String(data.as<const char*>()).toInt();
    applyPinByName(key, v);
  }
}

void processSseLine(const String& line) {
  if (line.startsWith(":")) return; // keep alive

  if (line.startsWith("data:")) {
    String payload = line.substring(5);
    payload.trim();
    if (payload.length() > 0) {
      handleFirebaseEvent(payload); // x·ª≠ l√Ω NGAY
    }
  }
}

void firebaseRealtimeLoop() {
  if (WiFi.status() != WL_CONNECTED) return;

  if (!sseClient.connected()) {
    if (millis() - lastReconnectTryMs < 2000) return;
    lastReconnectTryMs = millis();
    lineBuf = "";
    sseMsgData = "";
    Serial.println("Opening SSE stream...");
    openSseStream();
    return;
  }

  while (sseClient.available()) {
    char c = (char)sseClient.read();
    lastStreamByteMs = millis();

    if (c == '\r') continue;
    if (c == '\n') {
      processSseLine(lineBuf);
      lineBuf = "";
    } else {
      lineBuf += c;
      if (lineBuf.length() > 800) lineBuf = "";
    }
  }

  // timeout -> reconnect
  if (millis() - lastStreamByteMs > 45000) {
    Serial.println("‚è± SSE timeout -> reconnect");
    sseClient.stop();
  }
}

// ===================== TELEGRAM CONTROL =====================
void applyAndSync(const String& chat_id, int idx, int v) {
  applyPinByIndex(idx, v);
  bool ok = firebasePatchKey(keyMap[idx], v);
  bot.sendMessage(chat_id, ok ? "‚úÖ OK" : "‚ö†Ô∏è Firebase l·ªói", "");
}

void handleTelegram() {
  if (millis() - lastTgPollMs < TG_POLL_MS) return;
  lastTgPollMs = millis();

  int n = bot.getUpdates(bot.last_message_received + 1);
  for (int i = 0; i < n; i++) {
    String chat_id = bot.messages[i].chat_id;
    String text = bot.messages[i].text;
    text.trim();

    Serial.println("üì© Telegram: " + text);

    // show menu
    if (text == "/start" || text == "üìã MENU") {
      showMenu(chat_id);
      continue;
    }

    // UI buttons
    if (text == "Ki·ªÉm tra t√≠n hi·ªáu ON")  { applyAndSync(chat_id, 0, 1); continue; }
    if (text == "Ki·ªÉm tra t√≠n hi·ªáu OFF") { applyAndSync(chat_id, 0, 0); continue; }

    if (text == "Thi·∫øt b·ªã 1 ON")  { applyAndSync(chat_id, 1, 1); continue; }
    if (text == "Thi·∫øt b·ªã 1 OFF") { applyAndSync(chat_id, 1, 0); continue; }

    if (text == "Thi·∫øt b·ªã 2 ON")  { applyAndSync(chat_id, 2, 1); continue; }
    if (text == "Thi·∫øt b·ªã 2 OFF") { applyAndSync(chat_id, 2, 0); continue; }

    if (text == "Thi·∫øt b·ªã 3 ON")  { applyAndSync(chat_id, 3, 1); continue; }
    if (text == "Thi·∫øt b·ªã 3 OFF") { applyAndSync(chat_id, 3, 0); continue; }

    if (text == "Thi·∫øt b·ªã 4 ON")  { applyAndSync(chat_id, 4, 1); continue; }
    if (text == "Thi·∫øt b·ªã 4 OFF") { applyAndSync(chat_id, 4, 0); continue; }

    // optional: n·∫øu g√µ /help
    if (text == "/help") {
      bot.sendMessage(chat_id, "G√µ /start ƒë·ªÉ hi·ªán MENU", "");
      continue;
    }

    bot.sendMessage(chat_id, "Kh√¥ng hi·ªÉu. G√µ /start ƒë·ªÉ hi·ªán MENU", "");
  }
}

// ===================== SETUP / LOOP =====================
void setup() {
  Serial.begin(115200);

  pinMode(PINtest, OUTPUT);
  pinMode(PIN1, OUTPUT);
  pinMode(PIN2, OUTPUT);
  pinMode(PIN3, OUTPUT);
  pinMode(PIN4, OUTPUT);

  digitalWrite(PINtest, LOW);
  digitalWrite(PIN1, LOW);
  digitalWrite(PIN2, LOW);
  digitalWrite(PIN3, LOW);
  digitalWrite(PIN4, LOW);

  WiFi.begin(ssid, pass);
  Serial.print("Connecting WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(300);
    Serial.print(".");
  }
  Serial.println("\n‚úÖ WiFi connected: " + WiFi.localIP().toString());

  tgClient.setInsecure();
  sseClient.setInsecure();
  fbWriteClient.setInsecure();

  // m·ªü realtime stream
  openSseStream();

  Serial.println("üëâ V√†o Telegram chat v·ªõi bot v√† g√µ /start ƒë·ªÉ hi·ªán MENU");
}

void loop() {
  // 1) nghe Firebase realtime
  firebaseRealtimeLoop();

  // 2) nghe Telegram + menu + ƒëi·ªÅu khi·ªÉn
  handleTelegram();
}
